# 模板方法(钩子函数)
父类定义了一整套的骨架流程，而其中的某些方法，需要子类来完成，这样的好处是，方法流程已经定义好，子类要做的事情就是按着流程和模版自己写实现

# 单例模式
Q1: 序列化如何破坏单例？如何解决？
序列化的过程是通过ObjectOutPutStream将类写入文件，通过ObjectInputStream将类序列化文件从硬盘读出生成一个对象
在单例的序列化中，被反序列化的单例对象通过显示或者默认的readObject()去获取一个指向新的实例的引用INSTANCE 
原理是利用反射构建了一个新的对象，所以私有构造器是没有用的，readObject()等于是一个面向反序列化的、参数是字节流的公有构造器，这样就会破坏单例类中的一个INSTANCE指向同一个对象的原则

Q2: 枚举是如何防止序列化破坏单例的？
枚举可以保证不被破坏是因为枚举的实例底层编译是一个final static class，这样的实现类似于单例中静态常量模式的实现(饿汉式)，无法实现lazy-loading但保证了单例。类在被加载时是线程安全的，所以解决了线程问题。各种序列化方法，如writeObject、readObject、readObjectNoData、writeReplace和readResolve等会造成单例破坏的方法都是被禁用的，所以在JVM中，枚举类和枚举量都是唯一的，这就实现了自由序列化。
还可以通过序列化中的readResolve方法去保证序列化中的单例，前面说过，readObject会在反序列化中，为通过对象的字节流参数去新建一个对象，但是反序列化中readResolve方法可以去替换掉readObject新建的实例 ，这就实现了单例传递，而被新建的实例就会因为失去引用被GC线程回收。

# 责任链模式-ServletChain
"封装变化"